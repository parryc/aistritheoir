// Generated by CoffeeScript 1.6.3
var Inflection, Language, Orthography, Word, hungarian, hw;

Language = (function() {
  function Language(id) {
    this.id = id;
  }

  Language.prototype.defaultOrthography = "latin";

  Language.prototype.orthographies = {};

  Language.prototype.words = {};

  Language.prototype.inflections = {};

  Language.prototype.word = function(word, pos) {
    return this.words[word] = new Word(word, pos, this.orthographies[this.defaultOrthography]);
  };

  Language.prototype.orthography = function(orthography) {
    var id;
    id = this.defaultOrthography;
    return this.orthographies[id] = new Orthography(id, orthography);
  };

  Language.prototype.inflection = function(inflection) {
    return this.inflections[inflection.name] = new Inflection(inflection, false);
  };

  Language.prototype.inflect = function(word, form) {
    if (this.inflections[word.type]) {
      return this.inflections[word.type].inflect(word, form);
    } else {
      return console.log("There are no inflections of the type " + word.type);
    }
  };

  return Language;

})();

Orthography = (function() {
  function Orthography(id, orthography) {
    var key, letters;
    this.id = id;
    for (key in orthography) {
      letters = orthography[key];
      this[key] = letters;
    }
  }

  return Orthography;

})();

Word = (function() {
  function Word(word, pos, orthography) {
    var lemmaInfo;
    this.pos = pos;
    lemmaInfo = this.toLemma(word);
    this.lemma = lemmaInfo.lemma;
    this.type = lemmaInfo.type;
    this.o = orthography;
    this.vowel = this.getVowelType(this.lemma);
  }

  Word.prototype.count = function(letters) {
    return this.match(letters, false);
  };

  Word.prototype.has = function(letters) {
    return this.match(letters, true);
  };

  Word.prototype.match = function(letters, returnBoolean) {
    var match, matchCount, re;
    re = new RegExp(letters.split('').join('|'), "gi");
    match = this.lemma.match(re);
    if (match != null) {
      matchCount = match.length;
    } else {
      matchCount = 0;
    }
    if (returnBoolean) {
      return !matchCount;
    } else {
      return matchCount;
    }
  };

  Word.prototype.getVowelType = function() {
    var back, frontR, frontUR;
    back = this.count(this.o.vowels.back);
    frontR = this.count(this.o.vowels.front.rounded);
    frontUR = this.count(this.o.vowels.front.unrounded);
    switch (Math.max(back, Math.max(frontR, frontUR))) {
      case back:
        return "back";
      case frontR:
        return "front.rounded";
      case frontUR:
        return "front.unrounded";
    }
  };

  Word.prototype.toLemma = function(word) {
    if (word.substr(-2) === "ik") {
      return {
        "lemma": word.substr(0, word.length - 2),
        "type": this.pos + "+ik"
      };
    } else {
      return {
        "lemma": word,
        "type": this.pos
      };
    }
  };

  return Word;

})();

Inflection = (function() {
  function Inflection(inflection, isException) {
    if (isException) {
      this.parseException(inflection);
    } else {
      this.parseInflection(inflection);
    }
  }

  Inflection.prototype.mergeSuff = function(stem, suffix) {
    return stem + suffix.substr(1);
  };

  Inflection.prototype.mergeAff = function(affix, stem) {
    return affix.substr(affix.length - 1) + stem;
  };

  Inflection.prototype.parseException = function(inflection) {};

  Inflection.prototype.parseInflection = function(inflection) {
    var key, value;
    for (key in inflection) {
      value = inflection[key];
      if (key === "name" || key === "schema") {
        this[key] = value;
      } else {
        this[key] = this.substitutor(value.form, value.replacements, inflection.schema);
      }
    }
  };

  Inflection.prototype.substitutor = function(form, replacements, schema) {
    return function(word) {
      var ending, key, letters, re;
      ending = form;
      for (key in replacements) {
        letters = replacements[key];
        re = new RegExp(key, "gi");
        ending = ending.replace(re, letters[schema.indexOf(word.vowel)]);
      }
      return ending;
    };
  };

  Inflection.prototype.inflect = function(word, form) {
    return this.mergeSuff(word.lemma, this[form](word));
  };

  return Inflection;

})();

if (typeof module !== 'undefined' && (module.exports != null)) {
  exports.Language = Language;
  exports.Orthography = Orthography;
  exports.Word = Word;
  exports.Inflection = Inflection;
}

hungarian = new Language("hungarian");

hw = hungarian.words;

hungarian.orthography({
  "vowels": {
    "back": "aáoóuú",
    "front": {
      "rounded": "öőüű",
      "unrounded": "eéií"
    }
  }
});

hungarian.word("ért", "VERB");

hungarian.word("tanít", "VERB");

hungarian.inflection({
  "name": "VERB",
  "schema": ["front.unrounded", "front.rounded", "back"],
  "1sg": {
    "form": "+Vk",
    "replacements": {
      "V": ["e", "ö", "o"]
    }
  },
  "2sg": {
    "form": "+Vsz",
    "replacements": {
      "V": ["e", "e", "a"]
    }
  },
  "3sg": {
    "form": "+",
    "replacements": {}
  },
  "1pl": {
    "form": "+Vnk",
    "replacements": {
      "V": ["ü", "ü", "u"]
    }
  },
  "2pl": {
    "form": "+VtVk",
    "replacements": {
      "V": ["e", "ö", "o"]
    }
  },
  "3pl": {
    "form": "+VnVk",
    "replacements": {
      "V": ["e", "e", "a"]
    }
  }
});
