// Generated by CoffeeScript 1.6.3
var Inflection, Language, Orthography, PhraseStructure, Word, hungarian, hw;

Language = (function() {
  function Language(id) {
    this.id = id;
  }

  Language.prototype.defaultOrthography = "latin";

  Language.prototype.orthographies = {};

  Language.prototype.words = {};

  Language.prototype.inflections = {};

  Language.prototype.rules = {};

  Language.prototype.word = function(word, pos) {
    return this.words[word] = new Word(word, pos, this.orthographies[this.defaultOrthography]);
  };

  Language.prototype.orthography = function(orthography) {
    var id;
    id = this.defaultOrthography;
    return this.orthographies[id] = new Orthography(id, orthography);
  };

  Language.prototype.inflection = function(inflection) {
    return this.inflections[inflection.name] = new Inflection(inflection, false);
  };

  Language.prototype.inflect = function(word, form) {
    if (this.inflections[word.pos]) {
      return this.inflections[word.pos].inflect(word, form);
    } else {
      return console.log("There are no inflections of the type " + word.type);
    }
  };

  Language.prototype.phraseStructure = function(fromThis, toThis) {
    if (this.rules[fromThis]) {
      return this.rules[fromThis].push(toThis);
    } else {
      return this.rules[fromThis] = [toThis];
    }
  };

  return Language;

})();

Orthography = (function() {
  function Orthography(id, orthography) {
    var key, letters;
    this.id = id;
    for (key in orthography) {
      letters = orthography[key];
      this[key] = letters;
    }
  }

  Orthography.prototype.get = function(path) {
    var part, split, temp, _i, _len;
    split = path.split('.');
    temp = this;
    for (_i = 0, _len = split.length; _i < _len; _i++) {
      part = split[_i];
      temp = temp[part];
    }
    return temp;
  };

  return Orthography;

})();

Word = (function() {
  function Word(lemma, pos, orthography) {
    this.lemma = lemma;
    this.pos = pos;
    this.o = orthography;
    this.vowel = this.getVowelType(this.lemma);
  }

  Word.prototype.count = function(letters) {
    return this._match(letters, false);
  };

  Word.prototype.has = function(letters) {
    return this._match(letters, true);
  };

  Word.prototype._match = function(letters, returnBoolean) {
    var match, matchCount, re;
    re = new RegExp(letters.split('').join('|'), "gi");
    match = this.lemma.match(re);
    if (match != null) {
      matchCount = match.length;
    } else {
      matchCount = 0;
    }
    if (returnBoolean) {
      return !!matchCount;
    } else {
      return matchCount;
    }
  };

  Word.prototype.getVowelType = function() {
    var back, frontR, frontUR;
    back = this.count(this.o.vowels.back);
    frontR = this.count(this.o.vowels.front.rounded);
    frontUR = this.count(this.o.vowels.front.unrounded);
    switch (Math.max(back, Math.max(frontR, frontUR))) {
      case back:
        return "back";
      case frontR:
        return "front.rounded";
      case frontUR:
        return "front.unrounded";
    }
  };

  return Word;

})();

Inflection = (function() {
  function Inflection(inflection, isException) {
    if (isException) {
      this.parseException(inflection);
    } else {
      this.parseInflection(inflection);
    }
  }

  Inflection.prototype.mergeSuff = function(stem, suffix) {
    return stem + suffix.substr(1);
  };

  Inflection.prototype.mergeAff = function(stem, affix) {
    return affix.substr(affix.length - 1) + stem;
  };

  Inflection.prototype.parseException = function(inflection) {};

  Inflection.prototype.parseInflection = function(inflection) {
    var condition, key, parsedCondition, value, _ref;
    for (key in inflection) {
      value = inflection[key];
      if (key === "name" || key === "schema") {
        this[key] = value;
      } else {
        this[key] = {};
        if (value["default"]) {
          _ref = inflection[key];
          for (condition in _ref) {
            value = _ref[condition];
            parsedCondition = this._parseCondition(condition);
            this[key][parsedCondition] = this.substitutor(value.form, value.replacements, inflection.schema);
          }
        } else {
          this[key]["default"] = this.substitutor(value.form, value.replacements, inflection.schema);
        }
      }
    }
  };

  Inflection.prototype.substitutor = function(form, replacements, schema) {
    return function(word) {
      var ending, key, letters, re;
      ending = form;
      for (key in replacements) {
        letters = replacements[key];
        re = new RegExp(key, "gi");
        ending = ending.replace(re, letters[schema.indexOf(word.vowel)]);
      }
      return ending;
    };
  };

  Inflection.prototype.inflect = function(word, form) {
    var condition, inflection, inflector, match, re, root, trimOff;
    inflector = "default";
    root = word.lemma;
    for (condition in this[form]) {
      if (this._isDeleter(condition)) {
        re = new RegExp(condition.substr(1), "gi");
      } else {
        re = new RegExp(condition, "gi");
      }
      match = word.lemma.match(re);
      if (match != null) {
        inflector = condition;
      }
    }
    if (this._isDeleter(inflector)) {
      trimOff = inflector.substr(1, inflector.indexOf('$') - 1);
      root = word.lemma.substr(0, word.lemma.indexOf(trimOff));
    }
    inflection = this[form][inflector](word);
    if (inflection.substr(0, 1) === '+') {
      return this.mergeSuff(root, inflection);
    } else {
      return this.mergeAff(root, inflection);
    }
  };

  Inflection.prototype._parseCondition = function(condition) {
    if (this._isDeleter(condition)) {
      return condition + '$';
    }
    return condition;
  };

  Inflection.prototype._isDeleter = function(condition) {
    return condition.substr(0, 1) === '-';
  };

  return Inflection;

})();

PhraseStructure = (function() {
  function PhraseStructure(fromThis, toThis) {
    this.fromThis = fromThis;
    this.toThis = toThis;
    if (rules[fromThis]) {
      rules[fromThis].push(toThis);
    } else {
      rules[fromThis] = [toThis];
    }
  }

  PhraseStructure.prototype.rules = [];

  return PhraseStructure;

})();

if (typeof module !== 'undefined' && (module.exports != null)) {
  exports.Language = Language;
  exports.Orthography = Orthography;
  exports.Word = Word;
  exports.Inflection = Inflection;
}

hungarian = new Language("hungarian");

hw = hungarian.words;

hungarian.orthography({
  "vowels": {
    "back": "aáoóuú",
    "front": {
      "rounded": "öőüű",
      "unrounded": "eéií"
    }
  }
});

hungarian.word("ért", "VERB");

hungarian.word("tanít", "VERB");

hungarian.inflection({
  "name": "VERB",
  "schema": ["front.unrounded", "front.rounded", "back"],
  "1sg": {
    "default": {
      "form": "+Vk",
      "replacements": {
        "V": ["e", "ö", "o"]
      }
    },
    "-ik": {
      "form": "+Vm",
      "replacements": {
        "V": ["e", "ö", "o"]
      }
    }
  },
  "2sg": {
    "form": "+Vsz",
    "replacements": {
      "V": ["e", "e", "a"]
    }
  },
  "3sg": {
    "form": "+",
    "replacements": {}
  },
  "1pl": {
    "form": "+Vnk",
    "replacements": {
      "V": ["ü", "ü", "u"]
    }
  },
  "2pl": {
    "form": "+VtVk",
    "replacements": {
      "V": ["e", "ö", "o"]
    }
  },
  "3pl": {
    "form": "+VnVk",
    "replacements": {
      "V": ["e", "e", "a"]
    }
  }
});
