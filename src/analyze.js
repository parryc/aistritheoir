// Generated by CoffeeScript 1.6.3
var Analyzer;

Analyzer = (function() {
  function Analyzer(language) {
    var current, i, inflection, inflections, person, rule, schemaLength, verb, _i, _j, _len, _len1, _ref, _ref1;
    this.language = language;
    this.matrix = [];
    i = 0;
    while (i < 32) {
      this.matrix[i] = [i];
      this.matrix[i].length = 32;
      i++;
    }
    i = 0;
    while (i < 32) {
      this.matrix[0][i] = i;
      i++;
    }
    this.levenshteinDistance = function(__this, that, limit) {
      var cost, j, min, t, thatLength, that_j, thisLength, this_i;
      thisLength = __this.length;
      thatLength = that.length;
      if (Math.abs(thisLength - thatLength) > (limit || 16)) {
        return limit || 16;
      }
      if (thisLength === 0) {
        return thatLength;
      }
      if (thatLength === 0) {
        return thisLength;
      }
      i = 1;
      while (i <= thisLength) {
        this_i = __this[i - 1];
        j = 1;
        while (j <= thatLength) {
          if (i === j && this.matrix[i][j] > 4) {
            return thisLength;
          }
          that_j = that[j - 1];
          cost = (this_i === that_j ? 0 : 1);
          min = this.matrix[i - 1][j] + 1;
          if ((t = this.matrix[i][j - 1] + 1) < min) {
            min = t;
          }
          if ((t = this.matrix[i - 1][j - 1] + cost) < min) {
            min = t;
          }
          this.matrix[i][j] = min;
          j++;
        }
        i++;
      }
      return this.matrix[thisLength][thatLength];
    };
    this.persons = ['1sg', '2sg', '3sg', '1pl', '2pl', '3pl'];
    this.inflectionEndings = [];
    this.inflections = (function() {
      var _results;
      _results = [];
      for (inflections in language.inflectionsRaw) {
        _results.push(inflections);
      }
      return _results;
    })();
    this.markers = language.markersRaw;
    _ref = this.inflections;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      inflection = _ref[_i];
      verb = language.inflectionsRaw[inflection];
      schemaLength = verb.schema.length;
      this.inflectionEndings[inflection] = [];
      _ref1 = this.persons;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        person = _ref1[_j];
        this.inflectionEndings[inflection][person] = [];
        current = verb[person];
        if (!current['default']) {
          this.inflectionEndings[inflection][person] = this.replace(current, schemaLength);
        } else {
          for (rule in current) {
            this.inflectionEndings[inflection][person] = this.inflectionEndings[inflection][person].concat(this.replace(current[rule], schemaLength));
          }
        }
      }
    }
  }

  Analyzer.prototype.replace = function(sub, schemaLength) {
    var ending, key, letters, list, re, replacements, schemaPosition;
    list = [];
    replacements = sub['replacements'];
    schemaPosition = 0;
    while (schemaPosition < schemaLength) {
      ending = sub['form'];
      for (key in replacements) {
        letters = replacements[key];
        re = new RegExp(key, "gi");
        ending = ending.replace(re, letters[schemaPosition]);
      }
      list.push(ending.replace('+', ''));
      schemaPosition++;
    }
    return list.filter(function(value, index, self) {
      return self.indexOf(value) === index;
    });
  };

  Analyzer.prototype.getMorphology = function(word) {
    var potentials;
    potentials = this.getPerson(word);
    return this.getTense(potentials);
  };

  Analyzer.prototype.getPerson = function(word) {
    var currPers, ending, inflection, ld, min, minRoot, person, potentialEnding, potentialRoot, results, uninflected, wordEnding, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
    min = 0;
    currPers = "error";
    results = [];
    uninflected = [];
    _ref = this.inflections;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      inflection = _ref[_i];
      _ref1 = this.persons;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        person = _ref1[_j];
        minRoot = 'superlongsuperlongomfgomfg';
        potentialEnding = '';
        _ref2 = this.inflectionEndings[inflection][person];
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          ending = _ref2[_k];
          potentialRoot = word.substring(0, word.length - ending.length);
          wordEnding = word.substring(word.length - ending.length);
          ld = this.levenshteinDistance(wordEnding, ending);
          if (ld === 0 && potentialRoot.length < minRoot.length) {
            minRoot = potentialRoot;
            potentialEnding = ending;
          }
        }
        if (ending.length !== 0 && minRoot !== 'superlongsuperlongomfgomfg') {
          results.push({
            'original': word,
            'person': person,
            'root': minRoot,
            'inflection': inflection
          });
        } else {
          uninflected.push({
            'original': word,
            'person': person,
            'root': minRoot,
            'inflection': inflection
          });
        }
      }
    }
    if (results.length === 0) {
      results = uninflected;
    }
    return results;
  };

  Analyzer.prototype.getTense = function(potentials) {
    var found, info, marker, potential, potentialRoot, result, root, rule, tense, _i, _len;
    result = {};
    found = false;
    for (_i = 0, _len = potentials.length; _i < _len; _i++) {
      potential = potentials[_i];
      tense = potential.inflection.split('-').pop();
      if (tense === 'VERB') {
        tense = '';
      }
      marker = this.markers[tense];
      root = potential.root;
      if (marker != null) {
        for (rule in marker) {
          info = marker[rule];
          if (!(rule !== 'schema' && rule !== 'name')) {
            continue;
          }
          potentialRoot = root.substring(0, root.length - info.form.length - 1);
          if (!found && this.language.inflect(this.language.tempWord(potentialRoot, "VERB"), potential.person, tense) === potential.original) {
            result.root = potentialRoot;
            result.person = potential.person;
            result.tense = tense;
            found = true;
          }
        }
      } else if (!found && this.language.inflect(this.language.tempWord(root, "VERB"), potential.person, tense) === potential.original) {
        result.root = root;
        result.person = potential.person;
        result.tense = tense;
        found = true;
      }
    }
    return result;
  };

  Analyzer.prototype._unassimilate = function(rules, word) {
    var end, rule, _i, _len;
    rules = rules.split(',').reverse();
    for (_i = 0, _len = rules.length; _i < _len; _i++) {
      rule = rules[_i];
      rule = rule.trim();
      rule.replace(/\+/gi, "");
      if (rule.indexOf('remove') === 0) {
        word = word + rule.slice("remove".length + 1);
      }
      if (rule.indexOf('double') === 0) {
        end = word.match(/(\w)(\1+)/g).pop();
        word = word.replace(end, end.substring(end.length + 1));
      }
    }
    return word.replace(/\s/gi, "").replace(/_/gi, " ");
  };

  return Analyzer;

})();

if (typeof module !== 'undefined' && (module.exports != null)) {
  exports.Analyzer = Analyzer;
}
